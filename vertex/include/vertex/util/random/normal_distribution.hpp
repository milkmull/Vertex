#pragma once

#include <cmath>

#include "vertex/util/random/generate_canonical.hpp"

namespace vx {
namespace random {

// https://github.com/gcc-mirror/gcc/blob/master/libstdc%2B%2B-v3/include/bits/random.h#L2118

/**
 * @brief A normal (Gaussian) distribution for generating random floating-point numbers.
 *
 * The `normal_distribution` class generates random floating-point numbers following a normal (Gaussian)
 * distribution with a specified mean and standard deviation. The Box-Muller transform is used to generate
 * the random numbers efficiently.
 *
 * @tparam T The floating-point type (e.g., `float`, `double`) to be used for the distribution.
 */
template <typename T = double>
class normal_distribution
{
    static_assert(std::is_floating_point<T>::value, "T must be an floating point type");

public:

    using result_type = T;

    /**
     * @brief Parameter structure for the `normal_distribution`.
     *
     * This structure holds the mean and standard deviation for the normal distribution.
     */
    struct param_type
    {
        using distribution_type = normal_distribution<T>;

        /**
         * @brief Default constructor, initializes with mean = 0 and standard deviation = 1.
         */
        param_type() noexcept : param_type(0) {}

        /**
         * @brief Constructs the parameter object with the specified mean and standard deviation.
         *
         * @param mean The mean of the normal distribution.
         * @param stddev The standard deviation of the normal distribution. Default is 1.
         */
        explicit param_type(T mean, T stddev = static_cast<T>(1)) noexcept
            : m_mean(mean), m_stddev(stddev) {}

        /**
         * @brief Returns the mean of the normal distribution.
         *
         * @return The mean.
         */
        result_type mean() const noexcept { return m_mean; }

        /**
         * @brief Returns the standard deviation of the normal distribution.
         *
         * @return The standard deviation.
         */
        result_type stddev() const noexcept { return m_stddev; }

        friend bool operator==(const param_type& lhs, const param_type& rhs) noexcept
        {
            return lhs.m_mean == rhs.m_mean && lhs.m_stddev == rhs.m_stddev;
        }

        friend bool operator!=(const param_type& lhs, const param_type& rhs) noexcept
        {
            return !(lhs == rhs);
        }

    private:

        result_type m_mean;
        result_type m_stddev;
    };

public:

    /**
     * @brief Default constructor, initializes the distribution with mean = 0 and standard deviation = 1.
     */
    normal_distribution() noexcept : normal_distribution(0) {}

    /**
     * @brief Constructs the normal distribution with the specified mean and standard deviation.
     *
     * @param mean The mean of the normal distribution.
     * @param stddev The standard deviation of the normal distribution. Default is 1.
     */
    explicit normal_distribution(T mean, T stddev = static_cast<T>(1)) noexcept
        : m_param(mean, stddev) {}

    /**
     * @brief Constructs the normal distribution using a parameter object.
     *
     * @param p The parameter object containing the mean and standard deviation.
     */
    explicit normal_distribution(const param_type& p) noexcept : m_param(p) {}

    /**
     * @brief Returns the mean of the normal distribution.
     *
     * @return The mean.
     */
    result_type mean() const noexcept { return m_param.mean(); }

    /**
     * @brief Returns the standard deviation of the normal distribution.
     *
     * @return The standard deviation.
     */
    result_type stddev() const noexcept { return m_param.stddev(); }

    /**
     * @brief Returns the parameter object for the normal distribution.
     *
     * @return The parameter object containing the mean and standard deviation.
     */
    param_type param() const noexcept { return m_param; }

    /**
     * @brief Sets the parameter object for the normal distribution.
     *
     * @param p The parameter object to set.
     */
    void param(const param_type& p) noexcept { m_param = p; }

    /**
     * @brief Returns the minimum possible value generated by the distribution.
     *
     * @return The minimum value (negative infinity).
     */
    result_type min() const noexcept { return std::numeric_limits<T>::lowest(); }

    /**
     * @brief Returns the maximum possible value generated by the distribution.
     *
     * @return The maximum value (positive infinity).
     */
    result_type max() const noexcept { return std::numeric_limits<T>::max(); }

    /**
     * @brief Resets the distribution to its initial state.
     *
     * This function does nothing for the `normal_distribution`, but is provided to
     * conform to the standard.
     */
    void reset() noexcept { m_saved_available = false; }

    friend bool operator==(
        const normal_distribution& lhs,
        const normal_distribution& rhs
        ) noexcept
    {
        return lhs.m_param == rhs.m_param;
    }

    friend bool operator!=(
        const normal_distribution& lhs,
        const normal_distribution& rhs
        ) noexcept
    {
        return !(lhs == rhs);
    }

    /**
     * @brief Generates a random floating-point value based on the normal distribution.
     *
     * This function generates a random number based on the mean and standard deviation,
     * using the Box-Muller transform.
     *
     * @tparam RNG The type of the random number generator.
     * @param gen The random number generator to use.
     * @return A random floating-point value following the normal distribution.
     */
    template <typename RNG>
    result_type operator()(RNG& gen)
    {
        return operator()(gen, m_param);
    }

    /**
     * @brief Generates a random floating-point value based on the normal distribution and specific parameters.
     *
     * This function generates a random number based on the mean and standard deviation from the parameter object,
     * using the Box-Muller transform.
     *
     * @tparam RNG The type of the random number generator.
     * @param gen The random number generator to use.
     * @param p The parameter object containing the mean and standard deviation.
     * @return A random floating-point value following the normal distribution.
     */
    template <typename RNG>
    result_type operator()(RNG& gen, const param_type& p);

private:

    param_type m_param;
    bool m_saved_available = false;
    T m_saved = static_cast<T>(0);
};

// https://github.com/gcc-mirror/gcc/blob/440be01b07941506d1c8819448bd17c8717d55f5/libstdc%2B%2B-v3/include/bits/random.tcc#L1809

// https://en.wikipedia.org/wiki/Box%E2%80%93Muller_transform

template <typename T>
template <typename RNG>
typename normal_distribution<T>::result_type normal_distribution<T>::operator()(RNG& gen, const param_type& p)
{
    using rng_type = typename RNG::result_type;

    static_assert(
        std::is_integral<rng_type>::value && std::is_unsigned<rng_type>::value,
        "RNG::result_type must be an unsigned integral type"
    );

#   define generate_canonical(gen) random::generate_canonical<result_type, std::numeric_limits<result_type>::digits, RNG>(gen)

    result_type ret;

    if (m_saved_available)
    {
        m_saved_available = false;
        ret = m_saved;
    }
    else
    {
        result_type x, y, r2;

        do
        {
            x = static_cast<result_type>(2) * generate_canonical(gen) - static_cast<result_type>(1);
            y = static_cast<result_type>(2) * generate_canonical(gen) - static_cast<result_type>(1);
            r2 = x * x + y * y;

        } while (r2 > static_cast<result_type>(1) || r2 == static_cast<result_type>(0));

        const result_type mult = std::sqrt(static_cast<result_type>(-2) * std::log(r2) / r2);
        ret = y * mult;

        m_saved = x * mult;
        m_saved_available = true;
    }

    ret = ret * p.stddev() + p.mean();
    return ret;

#   undef generate_canonical
}

} // namespace random
} // namespace vx
