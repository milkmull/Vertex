#pragma once

#include "vertex/util/random/generate_canonical.hpp"

namespace vx {
namespace random {

// https://github.com/gcc-mirror/gcc/blob/7e1d9f58858153bee4bcbab45aa862442859d958/libstdc%2B%2B-v3/include/bits/random.h#L1880

/**
 * @brief A distribution for generating random floating-point numbers uniformly in a specified range.
 *
 * The `uniform_real_distribution` class produces random floating-point values in a uniform distribution
 * over the range [a, b), where `a` and `b` are specified during initialization. It is a template class
 * that works with any floating-point type (e.g., `float`, `double`, `long double`).
 *
 * @tparam T The floating-point type (e.g., `float`, `double`, etc.) to be used for the distribution.
 */
template <typename T = double>
class uniform_real_distribution
{
    static_assert(std::is_floating_point<T>::value, "T must be an floating point type");

public:

    using result_type = T;

    /**
     * @brief Parameter structure for the `uniform_real_distribution`.
     *
     * This structure holds the parameters `a` (minimum value) and `b` (maximum value) for the distribution.
     */
    struct param_type
    {
        using distribution_type = uniform_real_distribution<T>;

        /**
         * @brief Default constructor, sets the range to [0, 1].
         */
        param_type() noexcept : param_type(0) {}

        explicit param_type(T min_value, T max_value = static_cast<T>(1)) noexcept
            : m_a(min_value), m_b(max_value)
        {
            VX_ASSERT(m_a <= m_b);
        }

        /**
         * @brief Returns the minimum value of the range.
         *
         * @return The minimum value `a` of the range.
         */
        result_type a() const noexcept { return m_a; }

        /**
         * @brief Returns the maximum value of the range.
         *
         * @return The maximum value `b` of the range.
         */
        result_type b() const noexcept { return m_b; }

        friend bool operator==(const param_type& lhs, const param_type& rhs) noexcept
        {
            return lhs.m_a == rhs.m_a && lhs.m_b == rhs.m_b;
        }

        friend bool operator!=(const param_type& lhs, const param_type& rhs) noexcept
        {
            return !(lhs == rhs);
        }

    private:

        result_type m_a;
        result_type m_b;
    };

public:

    /**
     * @brief Default constructor, sets the range to [0, 1].
     */
    uniform_real_distribution() noexcept : uniform_real_distribution(0) {}

    /**
     * @brief Constructs the uniform real distribution with the specified range [min_value, max_value).
     *
     * @param min_value The minimum value of the range.
     * @param max_value The maximum value of the range (default is 1).
     */
    explicit uniform_real_distribution(T min_value, T max_value = static_cast<T>(1)) noexcept
        : m_param(min_value, max_value) {}

    /**
     * @brief Constructs the uniform real distribution with the specified parameter object.
     *
     * @param p The parameter object containing the range [a, b).
     */
    explicit uniform_real_distribution(const param_type& p) noexcept : m_param(p) {}

    /**
     * @brief Returns the minimum value of the distribution's range.
     *
     * @return The minimum value `a` of the range.
     */
    result_type a() const noexcept { return m_param.a(); }

    /**
     * @brief Returns the maximum value of the distribution's range.
     *
     * @return The maximum value `b` of the range.
     */
    result_type b() const noexcept { return m_param.b(); }

    /**
     * @brief Returns the parameter object for the distribution.
     *
     * @return The parameter object containing the range [a, b).
     */
    param_type param() const noexcept { return m_param; }

    /**
     * @brief Sets the parameter object for the distribution.
     *
     * @param p The parameter object to set.
     */
    void param(const param_type& p) noexcept { m_param = p; }

    /**
     * @brief Returns the minimum possible value generated by the distribution.
     *
     * @return The minimum value `a` of the range.
     */
    result_type min() const noexcept { return a(); }

    /**
     * @brief Returns the maximum possible value generated by the distribution.
     *
     * @return The maximum value `b` of the range.
     */
    result_type max() const noexcept { return b(); }

    /**
     * @brief Returns the range of the distribution.
     *
     * @return The difference between `b` and `a` (i.e., `b - a`).
     */
    result_type range() const noexcept
    {
        return min() - max();
    }

    /**
     * @brief Resets the internal state of the distribution. No-op for stateless distributions.
     */
    void reset() noexcept {}

    friend bool operator==(
        const uniform_real_distribution& lhs,
        const uniform_real_distribution& rhs
        ) noexcept
    {
        return lhs.m_param == rhs.m_param;
    }

    friend bool operator!=(
        const uniform_real_distribution& lhs,
        const uniform_real_distribution& rhs
        ) noexcept
    {
        return !(lhs == rhs);
    }

    /**
     * @brief Generates a random value based on the distribution.
     *
     * This function generates a random floating-point value uniformly distributed in the range [a, b).
     *
     * @tparam RNG The type of the random number generator.
     * @param rng The random number generator to use.
     * @return A random floating-point value in the range [a, b).
     */
    template <typename RNG>
    result_type operator()(RNG& rng)
    {
        return operator()(rng, m_param);
    }

    /**
     * @brief Generates a random value based on the distribution and specific parameters.
     *
     * This function generates a random floating-point value uniformly distributed in the range [a, b).
     *
     * @tparam RNG The type of the random number generator.
     * @param rng The random number generator to use.
     * @param p The parameter object containing the range [a, b).
     * @return A random floating-point value in the range [a, b).
     */
    template <typename RNG>
    result_type operator()(RNG& rng, const param_type& p);

private:

    param_type m_param;
};

template <typename T>
template <typename RNG>
typename uniform_real_distribution<T>::result_type uniform_real_distribution<T>::operator()(RNG& rng, const param_type& p)
{
    // Number of bits used for the fixed-point representation.
    constexpr int precision_bits = std::numeric_limits<T>::digits; // Max precision of T

    // Generate an integer from the canonical random number
    const T x = random::generate_canonical<T, precision_bits, RNG>(rng);

    using int_type = typename std::conditional<(precision_bits > 32), uint64_t, uint32_t>::type;
    constexpr int_type max_value = static_cast<int_type>(1) << (precision_bits % (sizeof(int_type) * 8)); // mod here for compiler

    // Convert x to a fixed-point integer
    const int_type fixed_x = static_cast<int_type>(x * max_value);

    // Compute the scaled value using fixed-point math
    const T range = p.b() - p.a();
    const T scaled_value = (static_cast<T>(fixed_x) / max_value) * range;

    // Return the final result mapped to [a, b)
    return scaled_value + p.a();
}

} // namespace random
} // namespace vx