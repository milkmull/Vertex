#pragma once

#include <cmath>

#include "vertex/config/language_config.hpp"
#include "vertex/math/type_traits.hpp"

namespace vx {
namespace math {

///////////////////////////////////////////////////////////////////////////////
// min
///////////////////////////////////////////////////////////////////////////////

#if defined(min)
#   undef min
#endif

template <typename T>
VX_FORCE_INLINE constexpr T min(T x, T y)
{
    return std::min(x, y);
}

template <typename T, typename... Ts>
VX_FORCE_INLINE constexpr T min(T x, T y, Ts... rest)
{
    return min((y < x) ? y : x, rest...);
}

///////////////////////////////////////////////////////////////////////////////
// max
///////////////////////////////////////////////////////////////////////////////

#if defined(max)
#   undef max
#endif

template <typename T>
VX_FORCE_INLINE constexpr T max(T x, T y)
{
    return std::max(x, y);
}

template <typename T, typename... Ts>
VX_FORCE_INLINE constexpr T max(T x, T y, Ts... rest)
{
    return max((y < x) ? y : x, rest...);
}

///////////////////////////////////////////////////////////////////////////////
// abs
///////////////////////////////////////////////////////////////////////////////

template <typename T, VXM_REQ_NUM(T)>
VX_FORCE_INLINE constexpr T abs(T x)
{
    return std::abs(x);
}

///////////////////////////////////////////////////////////////////////////////
// round
///////////////////////////////////////////////////////////////////////////////

template <typename T, VXM_REQ_FLOAT(T)>
VX_FORCE_INLINE constexpr T round(T x)
{
    return std::round(x);
}

///////////////////////////////////////////////////////////////////////////////
// trunc
///////////////////////////////////////////////////////////////////////////////

template <typename T, VXM_REQ_FLOAT(T)>
VX_FORCE_INLINE constexpr T trunc(T x)
{
    return std::trunc(x);
}

///////////////////////////////////////////////////////////////////////////////
// floor
///////////////////////////////////////////////////////////////////////////////

template <typename T, VXM_REQ_FLOAT(T)>
VX_FORCE_INLINE constexpr T floor(T x)
{
    return std::floor(x);
}

///////////////////////////////////////////////////////////////////////////////
// ceil
///////////////////////////////////////////////////////////////////////////////

template <typename T, VXM_REQ_FLOAT(T)>
VX_FORCE_INLINE constexpr T ceil(T x)
{
    return std::ceil(x);
}

///////////////////////////////////////////////////////////////////////////////
// sign
///////////////////////////////////////////////////////////////////////////////

template <typename T, VXM_REQ_NUM(T)>
VX_FORCE_INLINE constexpr T sign(T x)
{
    return static_cast<T>((static_cast<T>(0) < x) - (static_cast<T>(0) > x));
}

///////////////////////////////////////////////////////////////////////////////
// fmod
///////////////////////////////////////////////////////////////////////////////

template <typename T, VXM_REQ_FLOAT(T)>
VX_FORCE_INLINE constexpr T fmod(T x, T y)
{
    return x - y * std::trunc(x / y);
}

///////////////////////////////////////////////////////////////////////////////
// mod
///////////////////////////////////////////////////////////////////////////////

// https://registry.khronos.org/OpenGL-Refpages/gl4/html/mod.xhtml

template <typename T, VXM_REQ_FLOAT(T)>
VX_FORCE_INLINE constexpr T mod(T x, T y)
{
    return x - y * std::floor(x / y);
}

template <typename T, VXM_REQ_INT(T)>
VX_FORCE_INLINE constexpr T mod(T x, T y)
{
    return (x % y + y) % y;
}

///////////////////////////////////////////////////////////////////////////////
// fract
///////////////////////////////////////////////////////////////////////////////

// https://registry.khronos.org/OpenGL-Refpages/gl4/html/fract.xhtml

template <typename T, VXM_REQ_FLOAT(T)>
VX_FORCE_INLINE constexpr T fract(T x)
{
    return x - std::floor(x);
}

///////////////////////////////////////////////////////////////////////////////
// modf
///////////////////////////////////////////////////////////////////////////////

template <typename T, VXM_REQ_FLOAT(T)>
VX_FORCE_INLINE constexpr auto modf(T x, T& intpart)
{
    return std::modf(x, &intpart);
}

///////////////////////////////////////////////////////////////////////////////
// fma
///////////////////////////////////////////////////////////////////////////////

template <typename T, VXM_REQ_FLOAT(T)>
VX_FORCE_INLINE constexpr auto fma(T x, T y, T z)
{
    return std::fma(x, y, z);
}

///////////////////////////////////////////////////////////////////////////////
// frexp
///////////////////////////////////////////////////////////////////////////////

template <typename T, VXM_REQ_FLOAT(T)>
VX_FORCE_INLINE constexpr auto frexp(T x, int& exp)
{
    const T f = std::frexp(x, &exp);
    return f;
}

///////////////////////////////////////////////////////////////////////////////
// ldexp
///////////////////////////////////////////////////////////////////////////////

template <typename T, VXM_REQ_FLOAT(T)>
VX_FORCE_INLINE constexpr T ldexp(T x, int exp)
{
    return std::ldexp(x, exp);
}

///////////////////////////////////////////////////////////////////////////////
// clamp
///////////////////////////////////////////////////////////////////////////////

template <typename T>
VX_FORCE_INLINE constexpr T clamp(T x, T min, T max)
{
    const T t = x < min ? min : x;
    return t > max ? max : t;
}

///////////////////////////////////////////////////////////////////////////////
// gdc
///////////////////////////////////////////////////////////////////////////////

template <typename T, VXM_REQ_INT(T)>
VX_FORCE_INLINE constexpr T gcd(T a, T b)
{
    while (b != static_cast<T>(0))
    {
        T temp = b;
        b = a % b;
        a = temp;
    }

    return a;
}

} // namespace math
} // namespace vx