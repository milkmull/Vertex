#include "vertex_impl/app/video/_platform/windows/windows_video.hpp"
#include "vertex_impl/app/video/_platform/windows/windows_window.hpp"

namespace vx {
namespace app {
namespace video {

///////////////////////////////////////////////////////////////////////////////
// pump_events
///////////////////////////////////////////////////////////////////////////////

// https://github.com/libsdl-org/SDL/blob/main/src/video/windows/SDL_windowsevents.c#L2505

void video_instance_impl::pump_events()
{
    MSG msg;
    int new_msg = 0;

    // We explicitly want to use GetTickCount(), not GetTickCount64()
    VX_DISABLE_MSVC_WARNING_PUSH();
    VX_DISABLE_MSVC_WARNING(28159);
    const DWORD end_ticks = ::GetTickCount() + 1;
    VX_DISABLE_MSVC_WARNING_POP();

    if (data.enable_message_loop_hint_cache)
    {
        while (::PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
        {
            //if (msg.message == WM_MOUSEMOVE)
            //{
            //
            //}

            // Always translate the message in case it's an external window (e.g. with Qt integration)
            ::TranslateMessage(&msg);
            ::DispatchMessage(&msg);

            // Make sure we don't busy loop here forever if there are lots of events coming in
            if ((end_ticks - msg.time) <= 0)
            {
                /* We might get a few new messages generated by the Steam overlay or other application hooks
                   In this case those messages will be processed before any pending input, so we want to continue after those messages.
                   (thanks to Peter Deayton for his investigation here)
                 */
                ++new_msg;

                enum { MAX_NEW_MESSAGES = 3 };
                if (new_msg > MAX_NEW_MESSAGES)
                {
                    break;
                }
            }
        }
    }

    // keyboard
    {
        /* Windows loses a shift KEYUP event when you have both pressed at once and let go of one.
           You won't get a KEYUP until both are released, and that keyup will only be for the second
           key you released. Take heroic measures and check the keystate as of the last handled event,
           and if we think a key is pressed when Windows doesn't, unstick it in SDL's state. */

        //const auto& keystate = video->data.keyboard_ptr->get_keyboard_state();
        //
        //if (keystate[keyboard::SCANCODE_LSHIFT] && !(::GetKeyState(VK_LSHIFT) & 0x8000))
        //{
        //    video->data.keyboard_ptr->send_key(keyboard::GLOBAL_KEYBOARD_ID, 0, keyboard::SCANCODE_LSHIFT, false);
        //}
        //if (keystate[keyboard::SCANCODE_RSHIFT] && !(::GetKeyState(VK_LSHIFT) & 0x8000))
        //{
        //    video->data.keyboard_ptr->send_key(keyboard::GLOBAL_KEYBOARD_ID, 0, keyboard::SCANCODE_RSHIFT, false);
        //}
        //
        ///* The Windows key state gets lost when using Windows+Space or Windows+G shortcuts and
        //   not grabbing the keyboard. Note: If we *are* grabbing the keyboard, GetKeyState()
        //   will return inaccurate results for VK_LWIN and VK_RWIN but we don't need it anyway. */
        //
        //const window* focused = video->data.keyboard_ptr->get_focus();
        //if (!focused || !(focus))
    }

}

///////////////////////////////////////////////////////////////////////////////
// wait_event_timeout
///////////////////////////////////////////////////////////////////////////////

// https://github.com/libsdl-org/SDL/blob/main/src/video/windows/SDL_windowsevents.c#L2450

bool video_instance_impl::wait_event_timeout(time::time_point t)
{
    if (!data.enable_message_loop_hint_cache)
    {
        return false;
    }

    const DWORD timeout = t.is_negative() ? INFINITE : static_cast<DWORD>(t.as_nanoseconds());
    const DWORD ret = ::MsgWaitForMultipleObjectsEx(0, NULL, FALSE, timeout, QS_ALLINPUT);

    return (ret == WAIT_OBJECT_0);
}

///////////////////////////////////////////////////////////////////////////////
// send_wakeup_event
///////////////////////////////////////////////////////////////////////////////

void video_instance_impl::send_wakeup_event(window* w)
{
    //::PostMessage(w->impl_ptr->handle, video->impl_ptr->data._VX_WAKEUP, 0, 0);
}

///////////////////////////////////////////////////////////////////////////////
// event process
///////////////////////////////////////////////////////////////////////////////

// https://github.com/libsdl-org/SDL/blob/main/src/video/windows/SDL_windowsevents.c#L1150C1-L1150C83

LRESULT CALLBACK window_instance_impl::window_proc(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
{
    //window* win = nullptr;
    //LRESULT return_code = -1;

//    if (Msg == WM_CREATE)
//    {
//        // From the data passed into CreateWindow, we can extract the last
//        // argument which was a pointer to the window instance. We can then
//        // set the user data of the win32 window to a pointer to our window.
//        CREATESTRUCT* create_struct = reinterpret_cast<CREATESTRUCT*>(lParam);
//        win = reinterpret_cast<window*>(create_struct->lpCreateParams);
//        SetWindowLongPtr(hWnd, GWLP_USERDATA, reinterpret_cast<LONG_PTR>(win));
//    }
//    else
//    {
//        // Get the pointer to our associated window
//        win = reinterpret_cast<window*>(GetWindowLongPtr(hWnd, GWLP_USERDATA));
//
//        if (!win)
//        {
//            // If we have not yet gotten the WM_CREATE event, search for a match
//            for (auto& w : s_video_data->windows)
//            {
//                if (w && w->m_impl && w->m_impl->m_handle == hWnd)
//                {
//                    win = w.get();
//                    break;
//                }
//            }
//        }
//    }
//
//    if (!win || !win->validate())
//    {
//        return CallWindowProc(DefWindowProc, hWnd, Msg, wParam, lParam);
//    }
//
//    window_impl* win_impl = win->m_impl.get();
//
//    switch (Msg)
//    {
//        ///////////////////////////////////////////////////////////////////////////////
//        // window events
//        ///////////////////////////////////////////////////////////////////////////////
//
//        case WM_CLOSE:
//        {
//            win->post_window_close_requested();
//            return_code = 0;
//            break;
//        }
//
//        case WM_SHOWWINDOW:
//        {
//            if (wParam)
//            {
//                win->post_window_shown();
//            }
//            else
//            {
//                win->post_window_hidden();
//            }
//
//            break;
//        }
//
//        case WM_WINDOWPOSCHANGING:
//        {
//            if (win_impl->m_expected_resize)
//            {
//                return_code = 0;
//            }
//
//            // If we are going from a fixed size state to a floating state, we
//            // update the position to reflect the cached floating rect position
//            // and size.
//            if (win_impl->m_floating_rect_pending &&
//                !IsIconic(hWnd) &&
//                !IsZoomed(hWnd) &&
//                (win->m_flags & (window::flags::MINIMIZED | window::flags::MAXIMIZED)) &&
//                !(win->m_flags & window::flags::FULLSCREEN))
//            {
//                WINDOWPOS* wp = reinterpret_cast<WINDOWPOS*>(lParam);
//
//                RECT rect{};
//                win_impl->adjust_rect(rect, window::rect_type::FLOATING);
//
//                wp->x = rect.left;
//                wp->y = rect.top;
//                wp->cx = rect.right - rect.left;
//                wp->cy = rect.bottom - rect.top;
//                wp->flags &= ~(SWP_NOSIZE | SWP_NOMOVE);
//
//                win_impl->m_floating_rect_pending = false;
//            }
//
//            break;
//        }
//
//        case WM_WINDOWPOSCHANGED:
//        {
//            const WINDOWPOS* wp = reinterpret_cast<const WINDOWPOS*>(lParam);
//
//            if (wp->flags & SWP_SHOWWINDOW)
//            {
//                win->post_window_shown();
//            }
//
//            bool minimized = IsIconic(hWnd);
//            bool maximized = IsZoomed(hWnd);
//
//            if (minimized)
//            {
//                win->post_window_minimized();
//            }
//            else if (maximized)
//            {
//                // If we are going from a minimized state to maximized, restore first
//                if (win->m_flags & window::flags::MINIMIZED)
//                {
//                    win->post_window_restored();
//                }
//
//                win->post_window_maximized();
//            }
//            else if (win->m_flags & (window::flags::MINIMIZED | window::flags::MAXIMIZED))
//            {
//                win->post_window_restored();
//            }
//
//            if (wp->flags & SWP_HIDEWINDOW)
//            {
//                win->post_window_hidden();
//            }
//
//            /* When the window is minimized it's resized to the dock icon size, ignore this */
//            if (minimized || win->m_initializing)
//            {
//                break;
//            }
//
//            RECT rect{};
//
//            if (GetClientRect(hWnd, &rect) && !IS_RECT_EMPTY(rect))
//            {
//                POINT shift{};
//                ClientToScreen(hWnd, &shift);
//                win->post_window_moved(rect.left + shift.x, rect.top + shift.y);
//            }
//
//            // If the window moved between displays when handling window move event, the size may have changed
//            if (GetClientRect(hWnd, &rect) && !IS_RECT_EMPTY(rect))
//            {
//                win->post_window_resized(rect.right, rect.bottom);
//            }
//
//            // update clip cursor
//
//            // Forces a WM_PAINT event
//            InvalidateRect(hWnd, NULL, FALSE);
//            break;
//        }
//
//        // Correct aspect ratio if desired
//        case WM_SIZING:
//        {
//            // If aspect is not locked, skip
//            if (win->m_locked_aspect <= 0.0f)
//            {
//                break;
//            }
//
//            // Retrieve the rectangle being dragged by the user, which represents
//            // the full window's new size and position, including non-client areas.
//            RECT* drag_rect = reinterpret_cast<RECT*>(lParam);
//            RECT client_drag_rect = *drag_rect;
//            RECT rect{};
//
//            if (!win_impl->adjust_rect(rect, window::rect_type::INPUT))
//            {
//                break;
//            }
//
//            // Subtract the non-client area dimensions (borders, title bar, etc.)
//            // from the drag rectangle to calculate the client area size.
//            // This ensures that we can maintain the correct client area size or
//            // aspect ratio by focusing on the actual drawable area within the window.
//            client_drag_rect.left -= rect.left;
//            client_drag_rect.top -= rect.top;
//            client_drag_rect.right -= rect.right;
//            client_drag_rect.bottom -= rect.bottom;
//
//            int w = client_drag_rect.right - client_drag_rect.left;
//            int h = client_drag_rect.bottom - client_drag_rect.top;
//            //float new_aspect = static_cast<float>(w) / static_cast<float>(h);
//
//            switch (wParam)
//            {
//                case WMSZ_LEFT:
//                case WMSZ_RIGHT:
//                {
//                    h = static_cast<int>(math::round(w / win->m_locked_aspect));
//                    break;
//                }
//                default:
//                {
//                    // Resizing by corners or top or bottom
//                    w = static_cast<int>(math::round(h * win->m_locked_aspect));
//                    break;
//                }
//            }
//
//            switch (wParam)
//            {
//                case WMSZ_TOPLEFT:
//                {
//                    client_drag_rect.left = client_drag_rect.right - w;
//                    client_drag_rect.top = client_drag_rect.bottom - h;
//                    break;
//                }
//                case WMSZ_LEFT:
//                case WMSZ_BOTTOMLEFT:
//                {
//                    client_drag_rect.left = client_drag_rect.right - w;
//                    client_drag_rect.bottom = h + client_drag_rect.top;
//                    break;
//                }
//                case WMSZ_RIGHT:
//                case WMSZ_BOTTOMRIGHT:
//                case WMSZ_BOTTOM:
//                {
//                    client_drag_rect.right = w + client_drag_rect.left;
//                    client_drag_rect.bottom = h + client_drag_rect.top;
//                    break;
//                }
//                case WMSZ_TOP:
//                case WMSZ_TOPRIGHT:
//                {
//                    client_drag_rect.right = w + client_drag_rect.left;
//                    client_drag_rect.top = client_drag_rect.bottom - h;
//                    break;
//                }
//            }
//
//            // Adjust the client drag rect to account for borders
//            if (!win_impl->adjust_rect(client_drag_rect, window::rect_type::INPUT))
//            {
//                break;
//            }
//
//            *drag_rect = client_drag_rect;
//
//            break;
//        }
//
//        // Fix violations of minimum or maximum size
//        case WM_GETMINMAXINFO:
//        {
//            if (win_impl->m_expected_resize)
//            {
//                break;
//            }
//
//            // Get the size of the window including the frame
//            MINMAXINFO* mmi = reinterpret_cast<MINMAXINFO*>(lParam);
//
//            RECT rect{};
//            GetWindowRect(hWnd, &rect);
//
//            int x = rect.left;
//            int y = rect.top;
//            int w = win->m_size.x;
//            int h = win->m_size.y;
//
//            // If the window has a border, it must be accounted for in the size
//            if (!(win->m_flags & window::flags::BORDERLESS))
//            {
//                rect.top = 0;
//                rect.left = 0;
//                rect.bottom = h;
//                rect.right = w;
//                win_impl->adjust_rect(rect, window::rect_type::INPUT);
//
//                w = rect.right - rect.left;
//                h = rect.bottom - rect.top;
//            }
//
//            if ((win->m_flags & window::flags::RESIZABLE))
//            {
//                if (win->m_flags & window::flags::BORDERLESS)
//                {
//                    // Constrain borderless resizable windows to the screen
//
//                    int screen_w = GetSystemMetrics(SM_CXSCREEN);
//                    int screen_h = GetSystemMetrics(SM_CYSCREEN);
//
//                    mmi->ptMaxSize.x = math::max(w, screen_w);
//                    mmi->ptMaxSize.y = math::max(h, screen_h);
//                    mmi->ptMaxPosition.x = math::min(0, (screen_w - w) / 2);
//                    mmi->ptMaxPosition.y = math::max(0, (screen_h - h) / 2);
//                }
//
//                if (!GetClientRect(hWnd, &rect) || IS_RECT_EMPTY(rect))
//                {
//                    break;
//                }
//
//                if (win->m_min_size.x > 0)
//                {
//                    mmi->ptMinTrackSize.x = w + (win->m_min_size.x - rect.right);
//                }
//                if (win->m_min_size.y > 0)
//                {
//                    mmi->ptMinTrackSize.y = h + (win->m_min_size.y - rect.bottom);
//                }
//                if (win->m_max_size.x > 0)
//                {
//                    mmi->ptMaxTrackSize.x = w + (win->m_max_size.x - rect.right);
//                }
//                if (win->m_max_size.y > 0)
//                {
//                    mmi->ptMaxTrackSize.y = h + (win->m_max_size.y - rect.bottom);
//                }
//            }
//            else
//            {
//                mmi->ptMaxSize.x = w;
//                mmi->ptMaxSize.y = h;
//                mmi->ptMaxPosition.x = x;
//                mmi->ptMaxPosition.y = y;
//                mmi->ptMinTrackSize.x = w;
//                mmi->ptMinTrackSize.y = h;
//                mmi->ptMaxTrackSize.x = w;
//                mmi->ptMaxTrackSize.y = h;
//            }
//
//            return_code = 0;
//            break;
//        }
//
//        //case WM_ENTERSIZEMOVE:
//        //case WM_ENTERMENULOOP:
//        //{
//        //    SetTimer(hWnd, (UINT_PTR)SDL_IterateMainCallbacks, USER_TIMER_MINIMUM, NULL);
//        //    break;
//        //}
//
//        //case WM_TIMER:
//        //{
//        //    if (wParam == (UINT_PTR)SDL_IterateMainCallbacks) {
//        //        if (SDL_HasMainCallbacks()) {
//        //            SDL_IterateMainCallbacks(SDL_FALSE);
//        //        }
//        //        else {
//        //            // Send an expose event so the application can redraw
//        //            SDL_SendWindowEvent(data->window, SDL_EVENT_WINDOW_EXPOSED, 0, 0);
//        //        }
//        //        return 0;
//        //    }
//        //} break;
//        //
//        //case WM_EXITSIZEMOVE:
//        //case WM_EXITMENULOOP:
//        //{
//        //    KillTimer(hwnd, (UINT_PTR)SDL_IterateMainCallbacks);
//        //} break;
//
//        case WM_NCCALCSIZE:
//        {
//            if (wParam == TRUE && (win->m_flags & window::flags::BORDERLESS) && !(win->m_flags & window::flags::FULLSCREEN))
//            {
//                // If the window is not resizable, we need to manually adjust the client area size.
//                // This is necessary because without a border, the default behavior might not
//                // correctly calculate the size, leading to layout issues or incorrect rendering.
//                if (!(win->m_flags & window::flags::RESIZABLE))
//                {
//                    NCCALCSIZE_PARAMS* params = reinterpret_cast<NCCALCSIZE_PARAMS*>(lParam);
//
//                    params->rgrc[0].right = params->rgrc[0].left + win->m_floating_rect.size.x;
//                    params->rgrc[0].bottom = params->rgrc[0].top + win->m_floating_rect.size.y;
//                }
//
//                return 0;
//            }
//
//            break;
//        }
//
//        case WM_PAINT:
//        {
//            RECT rect{};
//
//            // Get the area that needs to be repainted
//            if (GetUpdateRect(hWnd, &rect, FALSE))
//            {
//                const LONG ex_style = GetWindowLong(hWnd, GWL_EXSTYLE);
//
//                // Composited windows will continue to receive WM_PAINT messages for
//                // update regions until the window is actually painted through Begin/EndPaint.
//                if (ex_style & WS_EX_COMPOSITED)
//                {
//                    PAINTSTRUCT ps;
//                    BeginPaint(hWnd, &ps);
//                    EndPaint(hWnd, &ps);
//                }
//
//                // Mark the update region as painted, which prevents redundant repainting
//                ValidateRect(hWnd, NULL);
//            }
//
//            return_code = 0;
//            break;
//        }
//
//        // Fill the background with black to prevent flicker
//        case WM_ERASEBKGND:
//        {
//            if (!win_impl->m_cleared)
//            {
//                RECT client_rect{};
//                HBRUSH brush;
//                win_impl->m_cleared = true;
//                GetClientRect(hWnd, &client_rect);
//                brush = CreateSolidBrush(0);
//                FillRect(GetDC(hWnd), &client_rect, brush);
//                DeleteObject(brush);
//            }
//            return 1;
//        }
//
//        ///////////////////////////////////////////////////////////////////////////////
//        // display events
//        ///////////////////////////////////////////////////////////////////////////////
//
//        case WM_DISPLAYCHANGE:
//        {
//            // Reacquire displays if any were added or removed
//            video::update_displays();
//            break;
//        }
//
//        ///////////////////////////////////////////////////////////////////////////////
//        // mouse events
//        ///////////////////////////////////////////////////////////////////////////////
//
//        case WM_SETCURSOR:
//        {
//            //uint16_t hittest = LOWORD(lParam);
//            //
//            //if (hittest == HTCLIENT)
//            //{
//            //    SetCursor(mouse::mouse_impl::get_current_cursor_handle());
//            //    return_code = 1;
//            //}
//            //else if (!g_WindowFrameUsableWhileCursorHidden && !SDL_cursor)
//            //{
//            //    SetCursor(NULL);
//            //    returnCode = TRUE;
//            //}
//
//            break;
//        }
//
//        default:
//        {
//            break;
//        }
//    }
//
//    if (return_code >= 0)
//    {
//        return return_code;
//    }

    return CallWindowProc(DefWindowProc, hWnd, Msg, wParam, lParam);
}

} // namespace video
} // namespace app
} // namespace vx